// Auto-generated file. Do not edit manually.
// Generated by: yarn generate-index-dts

declare module "socket-function/SetProcessVariables" {
    export {};

}

declare module "socket-function/SocketFunction" {
    /// <reference path="require/RequireController.d.ts" />
    /// <reference types="node" />
    /// <reference types="node" />
    import { SocketExposedInterface, SocketFunctionHook, SocketFunctionClientHook, SocketExposedShape, SocketRegistered, CallerContext, FullCallType, SocketRegisterType } from "socket-function/SocketFunctionTypes";
    import { SocketServerConfig } from "socket-function/src/webSocketServer";
    import { Args, MaybePromise } from "socket-function/src/types";
    import "./SetProcessVariables";
    type ExtractShape<ClassType, Shape> = {
        [key in keyof ClassType]: (key extends keyof Shape ? ClassType[key] extends SocketExposedInterface[""] ? ClassType[key] : ClassType[key] extends Function ? "All exposed function must be async (or return a Promise)" : never : "Function has implementation but is not exposed in the SocketFunction.register call");
    };
    export declare class SocketFunction {
        static logMessages: boolean;
        static trackMessageSizes: {
            upload: ((size: number) => void)[];
            download: ((size: number) => void)[];
            callTimes: ((obj: {
                start: number;
                end: number;
            }) => void)[];
        };
        static MAX_MESSAGE_SIZE: number;
        static HTTP_ETAG_CACHE: boolean;
        static silent: boolean;
        static HTTP_COMPRESS: boolean;
        static COEP: string;
        static COOP: string;
        static readonly WIRE_SERIALIZER: {
            serialize: (obj: unknown) => MaybePromise<Buffer[]>;
            deserialize: (buffers: Buffer[]) => MaybePromise<unknown>;
        };
        static WIRE_WARN_TIME: number;
        private static onMountCallbacks;
        static exposedClasses: Set<string>;
        static callerContext: CallerContext | undefined;
        static getCaller(): CallerContext;
        static harvestFailedCallCount: () => number;
        static getPendingCallCount: () => number;
        static harvestCallTimes: () => {
            start: number;
            end: number;
        }[];
        static register<ClassInstance extends object, Shape extends SocketExposedShape<{
            [key in keyof ClassInstance]: (...args: any[]) => Promise<unknown>;
        }>, Statics>(classGuid: string, instance: ClassInstance | (() => ClassInstance), shapeFnc: () => Shape, defaultHooksFnc?: () => SocketExposedShape[""] & {
            onMount?: () => MaybePromise<void>;
        }, config?: {
            /** @noAutoExpose If true SocketFunction.expose(Controller) must be called explicitly. */
            noAutoExpose?: boolean;
            statics?: Statics;
            /** Skip timing functions calls. Useful if a lot of functions have wait time that
                    is unrelated to processing, and therefore their timings won't be useful.
                    - Also useful if our auto function wrapping code is breaking functionality,
                        such as if you have a singleton function which you compare with ===,
                        which will breaks because we replaced it with a wrapped measure function.
            */
            noFunctionMeasure?: boolean;
        }): SocketRegistered<ExtractShape<ClassInstance, Shape>> & Statics;
        private static socketCache;
        static rehydrateSocketCaller<Controller>(socketRegistered: SocketRegisterType<Controller>, shapeFnc?: () => SocketExposedShape): SocketRegistered<Controller>;
        private static callFromGuid;
        static onNextDisconnect(nodeId: string, callback: () => void): void;
        static getLastDisconnectTime(nodeId: string): number | undefined;
        static isNodeConnected(nodeId: string): boolean;
        /** NOTE: Only works if the nodeIs used is from SocketFunction.connect (we can't convert arbitrary nodeIds into urls,
         *      as we have no way of knowing how to contain a nodeId).
         *  */
        static getHTTPCallLink(call: FullCallType): string;
        private static ignoreExposeCount;
        static ignoreExposeCalls<T>(code: () => Promise<T>): Promise<T>;
        /** Expose should be called before your mounting occurs. It mostly just exists to ensure you include the class type,
         *      so the class type's module construction runs, which should trigger register. Otherwise you would have
         *      to add additional imports to ensure the register call runs.
         */
        static expose(socketRegistered: SocketRegistered): void;
        static mountedNodeId: string;
        static isMounted(): boolean;
        static mountedIP: string;
        private static hasMounted;
        private static onMountCallback;
        static mountPromise: Promise<void>;
        static mount(config: SocketServerConfig): Promise<string>;
        /** Sets the default call when an http request is made, but no classGuid is set.
         *      NOTE: All other calls should be endpoint calls, even if those endpoints return a static file with an HTML content type.
         *          - However, to load new content, you should probably just use `require("./example.ts")`, which works on any files
         *              clientside that have also been required serverside (and whitelisted with module.allowclient = true,
         *              or with an `allowclient.flag` file in the directory or parent directory).
        */
        static setDefaultHTTPCall<Registered extends SocketRegistered, FunctionName extends keyof Registered["nodes"][""] & string>(registered: Registered, functionName: FunctionName, ...args: Args<Registered["nodes"][""][FunctionName]>): void;
        static connect(location: {
            address: string;
            port: number;
        }): string;
        static browserNodeId(): string;
        static getBrowserNodeId(): string;
        static addGlobalHook(hook: SocketFunctionHook): void;
        static addGlobalClientHook(hook: SocketFunctionClientHook): void;
    }
    declare global {
        var BOOTED_EDGE_NODE: {
            host: string;
        } | undefined;
    }
    export declare function _setSocketContext<T>(caller: CallerContext, code: () => T): T;
    export {};

}

declare module "socket-function/SocketFunctionTypes" {
    /// <reference path="require/RequireController.d.ts" />
    import { getCallObj } from "socket-function/src/nodeProxy";
    import { Args, MaybePromise } from "socket-function/src/types";
    export declare const socket: unique symbol;
    export type SocketExposedInterface = {
        [functionName: string]: (...args: any[]) => Promise<unknown>;
    };
    export type SocketInternalInterface = {
        [functionName: string]: {
            [getCallObj]: (...args: any[]) => FullCallType;
            (...args: any[]): Promise<unknown>;
        };
    };
    export type SocketExposedInterfaceClass = {
        new (): unknown;
        prototype: unknown;
    };
    export type FunctionFlags = {
        compress?: boolean;
        /** Indicates with the same input, we give the same output, forever,
         *      independent of code changes. This only works for data storage.
         */
        dataImmutable?: boolean;
        /** Allows overriding SocketFunction.MAX_MESSAGE_SIZE for responses from this function. */
        responseLimit?: number;
    };
    export type SocketExposedShape<ExposedType extends SocketExposedInterface = SocketExposedInterface> = {
        [functionName in keyof ExposedType]?: FunctionFlags & {
            hooks?: SocketFunctionHook[];
            clientHooks?: SocketFunctionClientHook[];
            noDefaultHooks?: boolean;
            /** BUG: I think this is broken if it is on the default hooks function? */
            noClientHooks?: boolean;
        };
    };
    export type FncType = (...args: any[]) => Promise<unknown>;
    export interface CallType<FncT extends FncType = FncType, FncName extends string = string> {
        classGuid: string;
        functionName: FncName;
        args: unknown[];
    }
    export interface FullCallType<FncT extends FncType = FncType, FncName extends string = string> extends CallType<FncT, FncName> {
        nodeId: string;
    }
    export interface SocketFunctionHook {
        (config: HookContext): MaybePromise<void>;
        /** NOTE: This is useful when we need a clientside hook to set up state specifically for our serverside hook. */
        clientHook?: SocketFunctionClientHook;
    }
    export type HookContext = {
        call: FullCallType;
        overrideResult?: unknown;
        onResult: ((result: unknown) => MaybePromise<void>)[];
    };
    export type ClientHookContext = {
        call: FullCallType;
        overrideResult?: unknown;
        onResult: ((result: unknown) => MaybePromise<void>)[];
        connectionId: {
            nodeId: string;
        };
    };
    export interface SocketFunctionClientHook {
        (config: ClientHookContext): MaybePromise<void>;
    }
    export interface SocketRegisterType<ExposedType = any> {
        _classGuid: string;
        _internalType: ExposedType;
    }
    export interface SocketRegistered<ExposedType = any> {
        nodes: {
            [nodeId: string]: {
                [functionName in keyof ExposedType]: ExposedType[functionName] & {
                    [getCallObj]: (...args: Args<ExposedType[functionName]>) => FullCallType;
                };
            };
        };
        _classGuid: string;
        _internalType: ExposedType;
    }
    export type ControllerPick<T extends SocketRegistered, K extends keyof T["_internalType"]> = (SocketRegistered<Pick<T["_internalType"], K>>);
    export type CallerContext = Readonly<CallerContextBase>;
    export type CallerContextBase = {
        nodeId: string;
        localNodeId: string;
    };

}

declare module "socket-function/hot/HotReloadController" {
    /// <reference path="../../typenode/index.d.ts" />
    /// <reference path="../require/RequireController.d.ts" />
    /** Enables some hot reload functionality.
     *      - Triggers a refresh clientside
     *      - Triggers a reload server, for modules marked with `module.hotreload`
     */
    export declare function watchFilesAndTriggerHotReloading(noAutomaticBrowserWatch?: boolean): void;
    declare global {
        namespace NodeJS {
            interface Module {
                /** Causes us to hotreload the file. Applies both serverside and clientside.
                 *      - If not set for any files clientside, we will refresh.
                 *      - If not set for any files serverside, we will do nothing (and just leave old code running).
                 */
                hotreload?: boolean;
                /** Overrides hotreload to disable hot reloading. Useful if you add "hotreload.flag" to a directory
                 *      (which sets hotreload on all files in and under that directory), but want a specific file
                 *      to not hotreload.
                 *  - Also useful if you want files to hotreload clientside, but not serverside.
                 */
                noserverhotreload?: boolean;
                watchAdditionalFiles?: string[];
            }
        }
        var isHotReloading: (() => boolean) | undefined;
    }
    export declare function isHotReloading(): boolean;
    export declare function hotReloadingGuard(): true;
    export declare function setExternalHotReloading(value: boolean): void;
    export declare function onHotReload(callback: (modules: NodeJS.Module[]) => void): void;
    export declare const HotReloadController: import("socket-function/SocketFunctionTypes").SocketRegistered<{
        watchFiles: () => Promise<void>;
        fileUpdated: (files: string[], changeTime: number) => Promise<void>;
    }>;

}

declare module "socket-function/mobx/UrlParam" {
    export declare class UrlParam<T> {
        private key;
        private defaultValue;
        constructor(key: string, defaultValue: T);
        valueSeqNum: {
            value: number;
        };
        get(): T;
        set(value: T): void;
        reset(): void;
        get value(): T;
        set value(value: T);
    }

}

declare module "socket-function/mobx/observer" {
    import type preact from "preact";
    import { Reaction } from "mobx";
    /** @deprecated Use the version from sliftutils instead. */ export declare function observer<T extends {
        new (...args: any[]): {
            render(): preact.ComponentChild;
            forceUpdate(callback?: () => void): void;
            componentWillUnmount?(): void;
        };
    }>(Constructor: T): {
        new (...args: any[]): {
            constructOrder: number;
            reaction: Reaction;
            componentWillUnmount(): void;
            render(): preact.ComponentChild;
            forceUpdate(callback?: () => void): void;
        };
        readonly name: string;
    } & T;

}

declare module "socket-function/mobx/promiseToObservable" {
    export interface InternalResult {
        result: {
            value: unknown;
        } | undefined;
    }
    export declare function promiseToObservable<T>(promise: Promise<T>, staleValue?: T): {
        value: T | undefined;
    };

}

declare module "socket-function/require/CSSShim" {
    /// <reference path="RequireController.d.ts" />
    export {};

}

declare module "socket-function/require/RequireController" {
    /// <reference path="../../typenode/index.d.ts" />
    /// <reference types="node" />
    /// <reference types="node" />
    declare global {
        namespace NodeJS {
            interface Module {
                /** Indicates the module is allowed clientside.
                 *  NOTE: Set with `module.allowclient = true`. HOWEVER, access via getIsAllowClient, which will check
                 */
                allowclient?: boolean;
                /** Causes the module to not preload, requiring `await import()` for it to load correctly
                 *      - Shouldn't be set recursively, otherwise nested packages will break.
                 */
                lazyload?: boolean;
                /** Indicates the module is definitely not allowed clientside */
                serveronly?: boolean;
                /** Used internally by RequireController */
                requireControllerSeqNum?: number;
                evalStartTime?: number;
                evalEndTime?: number;
                /** (Presently only called by require.js)
                 *      Called on require calls, to allow providers to create custom exports depending on the caller.
                 *          - Mostly used to allow functions to know the calling module.
                 */
                remapExports?: (exports: {
                    [key: string]: unknown;
                }, callerModule: NodeJS.Module) => {
                    [key: string]: unknown;
                };
                /** Only set if clientside (and allowed clientside) */
                source?: string;
            }
        }
        interface Window {
            clientsideBootTime: number;
        }
        var suppressUnexpectedModuleWarning: number | undefined;
    }
    /** Imports it, serverside, delayed. For dynamic imports, which we need to include once, but don't want to include
     *      immediately (due to cyclic issues), and isn't included initially.
     */
    export declare function lazyImport(getModule: () => Promise<unknown>): void;
    declare const requireSeqNumProcessId: string;
    declare function injectHTMLBeforeStartup(text: string | (() => Promise<string>)): void;
    declare function addStaticRoot(root: string): void;
    type GetModulesResult = ReturnType<RequireControllerBase["getModules"]> extends Promise<infer T> ? T : never;
    export type GetModulesArgs = Parameters<RequireControllerBase["getModules"]>;
    declare let mapGetModules: {
        remap(result: GetModulesResult, args: GetModulesArgs): Promise<GetModulesResult>;
    }[];
    declare function addMapGetModules(remap: typeof mapGetModules[number]["remap"]): void;
    declare class RequireControllerBase {
        rootResolvePath: string;
        requireHTML(config?: {
            requireCalls?: string[];
            cacheTime?: number;
        }): Promise<Buffer>;
        getModules(pathRequests: string[], alreadyHave?: {
            requireSeqNumProcessId: string;
            seqNumRanges: {
                s: number;
                e?: number;
            }[];
        }, config?: {}): Promise<{
            requestsResolvedPaths: string[];
            modules: {
                [resolvedPath: string]: SerializedModule;
            };
            requireSeqNumProcessId: string;
        }>;
    }
    export declare function getIsAllowClient(module: NodeJS.Module): boolean | undefined;
    type ClientRemapCallback = (args: GetModulesArgs) => Promise<GetModulesArgs>;
    declare global {
        /** Must be set clientside BEFORE requests are made (so you likely want to use RequireController.addMapGetModules
         *      to inject code that will use this) */
        var remapImportRequestsClientside: undefined | ClientRemapCallback[];
    }
    /** @deprecated, not needed, as this defaults to ".", which is a lot easier to reason about anyways. */
    export declare function setRequireBootRequire(dir: string): void;
    export declare function allowAllNodeModules(): void;
    export declare const RequireController: import("socket-function/SocketFunctionTypes").SocketRegistered<{
        rootResolvePath: "Function has implementation but is not exposed in the SocketFunction.register call";
        requireHTML: (config?: {
            requireCalls?: string[];
            cacheTime?: number;
        }) => Promise<Buffer>;
        getModules: (pathRequests: string[], alreadyHave?: {
            requireSeqNumProcessId: string;
            seqNumRanges: {
                s: number;
                e?: number;
            }[];
        }, config?: {}) => Promise<{
            requestsResolvedPaths: string[];
            modules: {
                [resolvedPath: string]: SerializedModule;
            };
            requireSeqNumProcessId: string;
        }>;
    }> & {
        injectHTMLBeforeStartup: typeof injectHTMLBeforeStartup;
        addMapGetModules: typeof addMapGetModules;
        addStaticRoot: typeof addStaticRoot;
        allowAllNodeModules: typeof allowAllNodeModules;
    };
    export {};

}

declare module "socket-function/require/compileFlags" {
    /// <reference path="RequireController.d.ts" />
    /// <reference types="node" />
    /**
     *      Adds a global function setFlag(require, "typescript", flag) which sets a flag on the client
     *          - Ex, setFlag(require, "typescript", "allowclient") so allowclient = true on the typescript module.
     *          - Passing true as the fourth argument sets it recursively
     */
    export declare const forceModule = true;
    declare global {
    }
    export declare function setFlag(require: NodeRequire, request: string, flag: string, recursive?: boolean): void;

}

declare module "socket-function/require/extMapper" {
    /// <reference types="node" />
    /// <reference types="node" />
    export declare function getExtContentType(ext: string): string;
    export declare function getContentTypeFromBuffer(buffer: Buffer): string | undefined;

}

declare module "socket-function/require/require" {
    /// <reference path="../src/src.d.ts" />
    declare global {
        var onProgressHandler: undefined | ((progress: {
            type: string;
            addValue: number;
            addMax: number;
        }) => void);
        var onErrorHandler: undefined | ((error: string) => void);
        var BOOT_TIME: number;
        var builtInModuleExports: {
            [key: string]: unknown;
        };
    }
    export declare function requireMain(): void;

}

declare module "socket-function/src/CallFactory" {
    /// <reference types="node" />
    /// <reference types="node" />
    /// <reference types="node" />
    import { CallType } from "socket-function/SocketFunctionTypes";
    import * as ws from "ws";
    import * as tls from "tls";
    export interface CallFactory {
        nodeId: string;
        lastClosed: number;
        closedForever?: boolean;
        isConnected?: boolean;
        performCall(call: CallType): Promise<unknown>;
        onNextDisconnect(callback: () => void): void;
        connectionId: {
            nodeId: string;
        };
    }
    export interface SenderInterface {
        nodeId?: string;
        _socket?: tls.TLSSocket;
        send(data: string | Buffer): void;
        addEventListener(event: "open", listener: () => void): void;
        addEventListener(event: "close", listener: () => void): void;
        addEventListener(event: "error", listener: (err: {
            message: string;
        }) => void): void;
        addEventListener(event: "message", listener: (data: ws.RawData | ws.MessageEvent | string) => void): void;
        readyState: number;
        ping?(): void;
    }
    export declare function harvestFailedCallCount(): number;
    export declare function getPendingCallCount(): number;
    export declare function harvestCallTimes(): {
        start: number;
        end: number;
    }[];
    export declare function createCallFactory(webSocketBase: SenderInterface | undefined, nodeId: string, localNodeId?: string): Promise<CallFactory>;

}

declare module "socket-function/src/JSONLACKS/JSONLACKS" {
    /// <reference types="node" />
    /// <reference types="node" />
    export interface JSONLACKS_ParseConfig {
        extended?: boolean;
        discardMissingReferences?: boolean;
    }
    export interface JSONLACKS_StringifyConfig {
        allowObjectMutation?: boolean;
    }
    interface HydrateState {
        references: Map<string, unknown>;
        visited: Set<unknown>;
    }
    export declare class JSONLACKS {
        static readonly LACKS_KEY = "__JSONLACKS__98cfb4a05fa34d828661cae15b8779ce__";
        /** If set to true parses non-quoted field names, comments, trailing commas, etc */
        static EXTENDED_PARSER: boolean;
        static IGNORE_MISSING_REFERENCES: boolean;
        static stringify(obj: unknown, config?: JSONLACKS_StringifyConfig): string;
        /** Is useful when serializing an array to a file with one object per line */
        static stringifyFile(obj: unknown[], config?: JSONLACKS_StringifyConfig): Promise<Buffer>;
        static stringifyFileSync(obj: unknown[], config?: JSONLACKS_StringifyConfig): Buffer;
        static parse<T>(text: string, config?: JSONLACKS_ParseConfig, hydrateState?: HydrateState): T;
        static parseLines<T>(buffer: Buffer, config?: JSONLACKS_ParseConfig): Promise<T[]>;
        private static escapeSpecialObjects;
        private static hydrateSpecialObjects;
    }
    export {};

}

declare module "socket-function/src/JSONLACKS/JSONLACKS.generated.js" {
    export function parse(text: string): unknown;
}

declare module "socket-function/src/Zip" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { MaybePromise } from "socket-function/src/types";
    export declare class Zip {
        static gzip(buffer: Buffer, level?: number): Promise<Buffer>;
        static gzipSync(buffer: Buffer, level?: number): Buffer;
        static gunzip(buffer: Buffer): MaybePromise<Buffer>;
        static gunzipAsyncBase(buffer: Buffer): Promise<Buffer>;
        static gunzipUntracked(buffer: Buffer): Promise<Buffer>;
        static gunzipSync(buffer: Buffer): Buffer;
        private static gunzipUntrackedSync;
        static gunzipBatch(buffers: Buffer[]): Promise<Buffer[]>;
    }

}

declare module "socket-function/src/args" {
    export declare const getArgs: {
        (): {
            [key: string]: string | undefined;
        };
        reset(): void;
        set(newValue: {
            [key: string]: string | undefined;
        }): void;
    };

}

declare module "socket-function/src/batching" {
    import { AnyFunction } from "socket-function/src/types";
    export type DelayType = (number | "afterio" | "immediate" | "afterpromises" | "paintLoop" | "afterPaint");
    export declare function delay(delayTime: DelayType, immediateShortDelays?: "immediateShortDelays"): Promise<void>;
    export declare function batchFunctionNone<Arg, Result = void>(config: unknown, fnc: (arg: Arg[]) => (Promise<Result> | Result)): (arg: Arg) => Promise<Result>;
    export declare function batchFunction<Arg, Result = void>(config: {
        delay: DelayType;
        /** Instead of immediately waiting delay, starts by waiting 0ms, and every call increments the delay factor
         *      by 1. Delay is `factor * (delay / throttleWindow)`. For every delay interval we have no calls, we decrease by
         *      no_calls/delay.
         *      - This essentially turns delay into a `calls per second` type indicator (ex, 10ms is 100 callers
         *          per second, 500ms is 2 calls, etc), which is accurate over delay * throttleWindow time.
         */
        throttleWindow?: number;
        name?: string;
        noMeasure?: boolean;
    }, fnc: (arg: Arg[]) => (Promise<Result> | Result)): (arg: Arg) => Promise<Result>;
    export declare function runInSerial<T extends (...args: any[]) => Promise<any>>(fnc: T): T;
    export declare function runInParallel<T extends (...args: any[]) => Promise<any>>(config: {
        parallelCount: number;
        callTimeout?: number;
    }, fnc: T): T;
    export declare function runInfinitePoll(delayTime: number, fnc: () => Promise<void> | void): void;
    export declare function runInfinitePollCallAtStart(delayTime: number, fnc: () => Promise<void> | void): Promise<void>;
    /** Disables polling, called on shutdown. Blocks until all pending poll loops finish */
    export declare function shutdownPolling(): Promise<void>;
    export declare function retryFunctional<T extends AnyFunction>(fnc: T, config?: {
        maxRetries?: number;
        shouldRetry?: (message: string) => boolean;
        minDelay?: number;
        maxDelay?: number;
    }): T;

}

declare module "socket-function/src/caching" {
    import { AnyFunction, Args } from "socket-function/src/types";
    export declare function lazy<T>(factory: () => T): {
        (): T;
        reset(): void;
        set(newValue: T): void;
    };
    export declare function cacheEmptyArray<T>(array: T[]): T[];
    export declare function cache<Output, Key, Untracked extends unknown[]>(getValue: (key: Key, ...untracked: Untracked) => Output): {
        (key: Key, ...untracked: Untracked): Output;
        clear(key: Key): void;
        clearAll(): void;
        forceSet(key: Key, value: Output): void;
        getAllKeys(): Key[];
        get(key: Key): Output | undefined;
    };
    /** Makes a cache that limits the number of entries, allowing you to put arbitrary data in it
     *      without worrying about leaking memory
      */
    export declare function cacheLimited<Output, Key>(maxCount: number, getValue: (key: Key) => Output): {
        (input: Key): Output;
        forceSet(key: Key, value: Output): void;
        clearKey(key: Key): void;
        clear(): void;
    };
    export declare function cacheWeak<Output, Key extends object>(getValue: (key: Key) => Output): (key: Key) => Output;
    export declare function cacheList<Value>(getLength: () => number, getValue: (index: number) => Value): {
        (index: number): Value;
    };
    /** A cache half way between caching based on === and caching based on hash. Caches
     *      based on arrayEqual, which does === on all values in an array. Requires localized
     *      caching (as the comparisons don't scale with many candidates, unlike hashing),
     *      however works with non trival transformations (ex, resolving many persisted overrides
     *      to get a value), unlike cache().
     *  Also, limits itself, more of a performance optimization than memory optimization, as it scales
     *      very poorly with the number of candidates.
     *
     *  TIMING: About 6us with limit = 100, array size = 294, and the cache being full.
     */
    export declare function cacheArrayEqual<Input extends unknown[] | undefined, Output>(map: (arrays: Input) => Output, limit?: number): {
        (array: Input): Output;
        clear(array: Input): void;
        clearAll(): void;
    };
    /** Caches when arguments are ===. See cacheArrayEqual */
    export declare function cacheArgsEqual<Fnc extends AnyFunction>(fnc: Fnc, limit?: number): Fnc & {
        clear(...args: Args<Fnc>): void;
    };
    export declare function cacheJSONArgsEqual<Fnc extends AnyFunction>(fnc: Fnc, limit?: number): Fnc & {
        clear(...args: unknown[]): void;
        clearAll(): void;
    };
    export declare function cacheShallowConfigArgEqual<Fnc extends AnyFunction>(fnc: Fnc, limit?: number): Fnc & {
        clear(configObj: Args<Fnc>[0]): void;
        clearAll(): void;
    };
    export declare function externalCache<Key, Value>(): {
        get: (key: Key) => Value | undefined;
        set: (key: Key, value: Value) => void;
    };

}

declare module "socket-function/src/callHTTPHandler" {
    /// <reference types="node" />
    /// <reference types="node" />
    /// <reference types="node" />
    import http from "http";
    import { CallType } from "socket-function/SocketFunctionTypes";
    export declare function setDefaultHTTPCall(call: CallType): void;
    export declare function getServerLocationFromRequest(request: http.IncomingMessage): {
        address: string;
        port: number;
    };
    export declare function getNodeIdsFromRequest(request: http.IncomingMessage): {
        nodeId: string;
        localNodeId: string;
    };
    export declare function getCurrentHTTPRequest(): http.IncomingMessage | undefined;
    export declare function httpCallHandler(request: http.IncomingMessage, response: http.ServerResponse): Promise<void>;
    declare const resultHeaders: unique symbol;
    type HTTPResultType = Buffer & {
        [resultHeaders]?: {
            [header: string]: string;
        };
    };
    export declare function setHTTPResultHeaders(result: HTTPResultType, headers: {
        [header: string]: string;
    }): HTTPResultType;
    export {};

}

declare module "socket-function/src/callManager" {
    /// <reference path="../hot/HotReloadController.d.ts" />
    import { CallerContext, CallType, ClientHookContext, FullCallType, FunctionFlags, HookContext, SocketExposedInterface, SocketExposedShape, SocketFunctionClientHook, SocketFunctionHook, SocketRegistered } from "socket-function/SocketFunctionTypes";
    export declare function getCallFlags(call: CallType): FunctionFlags | undefined;
    export declare function shouldCompressCall(call: CallType): boolean;
    export declare function performLocalCall(config: {
        call: FullCallType;
        caller: CallerContext;
    }): Promise<unknown>;
    export declare function isDataImmutable(call: CallType): boolean;
    export declare function registerClass(classGuid: string, controller: SocketExposedInterface, shape: SocketExposedShape, config?: {
        noFunctionMeasure?: boolean;
    }): void;
    export declare function exposeClass(exposedClass: SocketRegistered): void;
    export declare function registerGlobalHook(hook: SocketFunctionHook): void;
    export declare function unregisterGlobalHook(hook: SocketFunctionHook): void;
    export declare function registerGlobalClientHook(hook: SocketFunctionClientHook): void;
    export declare function unregisterGlobalClientHook(hook: SocketFunctionClientHook): void;
    export declare const runClientHooks: (callType: FullCallType, hooks: Exclude<SocketExposedShape[""], undefined>, connectionId: {
        nodeId: string;
    }) => Promise<ClientHookContext>;
    export declare const runServerHooks: (callType: FullCallType, caller: CallerContext, hooks: Exclude<SocketExposedShape[""], undefined>) => Promise<HookContext>;

}

declare module "socket-function/src/certStore" {
    /// <reference types="node" />
    /// <reference types="node" />
    /** Must be populated before the server starts */
    export declare function trustCertificate(cert: string | Buffer): void;
    export declare function getTrustedCertificates(): string[];
    export declare function watchTrustedCertificates(callback: (certs: string[]) => void): () => boolean;

}

declare module "socket-function/src/corsCheck" {

}

declare module "socket-function/src/fixLargeNetworkCalls" {
    export declare function markArrayAsSplitable<T>(data: T[]): T[];
    export declare function isSplitableArray<T>(data: T): data is T & (unknown[]);

}

declare module "socket-function/src/formatting/colors" {
    export type HSL = {
        h: number;
        s: number;
        l: number;
    };
    export declare function hslText(color: HSL): string;
    export declare function hslToRGB(color: HSL): {
        r: number;
        g: number;
        b: number;
    };
    export declare function hslToHex(color: HSL): string;
    export declare function hslLightenGamma(hsl: HSL, fraction: number): {
        h: number;
        s: number;
        l: number;
    };
    export declare function hslLightenLinear(hsl: HSL, lightness: number): {
        h: number;
        s: number;
        l: number;
    };
    export declare function hslDarkenGamma(hsl: HSL, fraction: number): {
        h: number;
        s: number;
        l: number;
    };
    export declare function hslDarkenLinear(hsl: HSL, lightness: number): {
        h: number;
        s: number;
        l: number;
    };
    export declare function hslAddSaturate(hsl: HSL, saturation: number): {
        h: number;
        s: number;
        l: number;
    };
    export declare function hslSetSaturate(hsl: HSL, saturation: number): {
        h: number;
        s: number;
        l: number;
    };

}

declare module "socket-function/src/formatting/format" {
    export declare function formatTime(milliseconds: number | undefined, maxAbsoluteValue?: number): string;
    export declare function getTargetDecimals(maxAbsoluteValue: number, targetDigits: number): number;
    /** Adds decimal digits to reach digits. If the number is simply too large, it won't remove
     *      digits, there will instead just be no decimal point.
     */
    export declare function formatMaxDecimals(num: number, targetDigits: number, maxAbsoluteValue?: number, exactDecimals?: number): string;
    /** Actually formats any number, including decimals, by using K, M and B suffixes to get smaller values
     *      TODO: Support uK, uM and uB suffixes for very small numbers?
     *      <= 6 characters (<= 5 if positive)
     */
    export declare function formatNumber(count: number | undefined, maxAbsoluteValue?: number, noDecimal?: boolean, specialCurrency?: boolean): string;
    export declare function formatBinaryNumber(count: number | undefined, maxAbsoluteValue?: number, noDecimal?: boolean, specialCurrency?: boolean): string;
    /** YYYY/MM/DD HH:MM:SS PM/AM */
    export declare function formatDateTime(time: number): string;
    export declare function formatDateTimeDetailed(time: number): string;
    export declare function formatFileTimestampLocal(time: number): string;
    /** 2024 January 1, Monday, 12:53:02pm */
    export declare function formatNiceDateTime(time: number): string;
    /** 2024 January 1, Monday, 12:53:02pm (4 months ago)  */
    export declare function formatVeryNiceDateTime(time: number): string;
    /** YYYY/MM/DD */
    export declare function formatDate(time: number): string;
    /** <= 6 characters (<= 5 if positive) */
    export declare function formatPercent(value: number): string;

}

declare module "socket-function/src/formatting/logColors" {
    export declare const blue: (text: string) => string;
    export declare const red: (text: string) => string;
    export declare const green: (text: string) => string;
    export declare const yellow: (text: string) => string;
    export declare const white: (text: string) => string;
    export declare const gray: (text: string) => string;
    export declare const magenta: (text: string) => string;

}

declare module "socket-function/src/forwardPort" {
    export declare function forwardPort(config: {
        externalPort: number;
        internalPort: number;
        duration?: number;
    }): Promise<void>;

}

declare module "socket-function/src/https" {
    /// <reference types="node" />
    /// <reference types="node" />
    export declare function httpsRequest(url: string, payload?: Buffer | Buffer[], method?: string, sendSessionCookies?: boolean, config?: {
        headers?: {
            [key: string]: string | undefined;
        };
        cancel?: Promise<void>;
    }): Promise<Buffer>;

}

declare module "socket-function/src/misc" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { MaybePromise } from "socket-function/src/types";
    export declare const timeInSecond = 1000;
    export declare const timeInMinute: number;
    export declare const timeInHour: number;
    export declare const timeInDay: number;
    export declare const timeInWeek: number;
    export declare const timeInYear: number;
    export type Watchable<T> = (callback: (value: T) => void) => MaybePromise<void>;
    export declare function convertErrorStackToError(error: string): Error;
    export declare function sha256Hash(buffer: Buffer | string): string;
    export declare function sha256HashBuffer(buffer: Buffer | string): Buffer;
    /** Async, but works both clientside and serverside. */
    export declare function sha256HashPromise(buffer: Buffer): Promise<any>;
    export declare function sha256BufferPromise(buffer: Buffer): Promise<Buffer>;
    export declare function arrayEqual(a: {
        [key: number]: unknown;
        length: number;
    }, b: {
        [key: number]: unknown;
        length: number;
    }): boolean;
    export declare function isNode(): boolean;
    export declare function isNodeTrue(): true;
    export declare function formatNumberSuffixed(count: number): string;
    export declare function list(count: number): number[];
    export declare function recursiveFreeze<T>(obj: T): T;
    export type ArrayBufferViewTypes = Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | BigUint64Array | BigInt64Array | Float64Array | Float32Array | Uint8ClampedArray;
    export type BufferType = ArrayBuffer | SharedArrayBuffer | ArrayBufferViewTypes;
    export declare function isBufferType(obj: unknown): obj is BufferType;
    export declare function getKeys(obj: unknown): PropertyKey[];
    export declare function getStringKeys<T extends {}>(obj: T): ((keyof T) & string)[];
    export declare function keyBy<T, K>(arr: T[], getKey: (value: T) => K): Map<K, T>;
    export declare function keyByArray<T, K>(arr: T[], getKey: (value: T) => K): Map<K, T[]>;
    export declare function deepCloneJSON<T>(obj: T): T;
    export declare class PromiseObj<T = void> {
        promise: Promise<T>;
        value: {
            value?: T;
            error?: string;
        } | undefined;
        /** Resolve called does not mean the value is ready, as it may be resolved with a promise. */
        resolveCalled?: boolean;
        resolve: (value: T | Promise<T>) => void;
        reject: (error: any) => void;
        private baseResolve;
        private baseReject;
        constructor();
    }
    export declare function promiseObj<T = void>(): PromiseObj<T>;
    export declare function throttleFunction<Args extends any[]>(delay: number, fnc: (...args: Args) => MaybePromise<void>): (...args: Args) => Promise<void>;
    export declare function nextId(): string;
    export declare function arrayFromOrderObject<T>(obj: {
        [order: number]: T;
    }): T[];
    export declare function last<T>(arr: T[]): T | undefined;
    export type ObjectValues<T> = T[keyof T];
    export declare function entries<Obj extends {
        [key: string]: unknown;
    }>(obj: Obj): [keyof Obj, ObjectValues<Obj>][];
    export declare function keys<Obj extends {
        [key: string]: unknown;
    }>(obj: Obj): (keyof Obj)[];
    export declare function sort<T>(arr: T[], sortKey: (obj: T) => unknown): T[];
    export declare function getRootDomain(hostname: string): string;
    export declare class QueueLimited<T> {
        private readonly maxCount;
        private items;
        private nextIndex;
        constructor(maxCount: number);
        push(item: T): void;
        getAllUnordered(): T[];
        reset(): void;
        clear(): void;
        getOldest(): T | undefined;
    }
    export declare function binarySearchBasic<T, V>(array: T[], getVal: (val: T) => V, searchValue: V): number;
    export declare function binarySearchBasic2<T, V>(array: T[], getVal: (val: T) => V, searchValue: T): number;
    /**
     *  Searches indexes, allowing you to query structures that aren't arrays. To search an array, use:
     *      `binarySearchIndex(array.length, i => compare(array[i], searchValue))`
     *
     *      NOTE: If there are duplicates, returns the first match.
     *
     *      NOTE: If the value can't be found, returns the bitwise negation of the index where it should be inserted.
     *
     *      NOTE: With `if (index < 0) index = ~index;` you will get an index of the value >= the target value.
     */
    export declare function binarySearchIndex(listCount: number, compare: (lhsIndex: number) => number): number;
    export declare function compare(lhs: unknown, rhs: unknown): number;
    export declare function compareArray(lhs: unknown[], rhs: unknown[]): number;
    export declare function insertIntoSortedList<T>(list: T[], map: (val: T) => string | number, element: T): void;
    export declare function removeFromSortedList<T>(list: T[], map: (val: T) => string | number, searchValue: string | number): void;
    export declare function timeoutToError<T>(time: number, p: Promise<T>, err: () => Error): Promise<T>;
    export declare function timeoutToUndefined<T>(time: number, p: Promise<T>): Promise<T | undefined>;
    export declare function timeoutToUndefinedSilent<T>(time: number, p: Promise<T>): Promise<T | undefined>;
    export declare function errorToWarning<T>(promise: Promise<T>): void;

}

declare module "socket-function/src/networking" {
    export declare const testTCPIsListening: (host: string, port: number) => Promise<boolean>;
    export declare const getExternalIP: {
        (): Promise<string>;
        reset(): void;
        set(newValue: Promise<string>): void;
    };
    export declare const getPublicIP: {
        (): Promise<string>;
        reset(): void;
        set(newValue: Promise<string>): void;
    };

}

declare module "socket-function/src/nodeCache" {
    import { CallFactory } from "socket-function/src/CallFactory";
    import { MaybePromise } from "socket-function/src/types";
    export declare function getNodeId(domain: string, port: number): string;
    /** @deprecated, call getBrowserUrlNode instead, which does important additional checks. */
    export declare function getNodeIdFromLocation(): string;
    /** A nodeId not available for reconnecting. */
    export declare function getClientNodeId(address: string): string;
    export declare function isClientNodeId(nodeId: string): boolean;
    /** Will always be available, even if getNodeIdLocation is not (as we don't always have the port,
     *      but we should always have an address).
     *  - Rarely used, as for logging you can just log the nodeId. ALSO, it isn't sufficient to reconnect, as the port is also needed!
     *  */
    export declare function getNodeIdIP(nodeId: string): string;
    export declare function getNodeIdLocation(nodeId: string): {
        address: string;
        port: number;
    } | undefined;
    export declare function getNodeIdDomain(nodeId: string): string;
    export declare function getNodeIdDomainMaybeUndefined(nodeId: string): string | undefined;
    export declare function registerNodeClient(callFactory: CallFactory): void;
    export declare function getCreateCallFactory(nodeId: string): MaybePromise<CallFactory>;
    export declare function getCallFactory(nodeId: string): MaybePromise<CallFactory | undefined>;
    export declare function resetAllNodeCallFactories(): void;
    export declare function countOpenConnections(): number;

}

declare module "socket-function/src/nodeProxy" {
    import { FullCallType, SocketInternalInterface } from "socket-function/SocketFunctionTypes";
    type CallProxyType = {
        [nodeId: string]: SocketInternalInterface;
    };
    export declare const getCallObj: unique symbol;
    export declare function getCallProxy(id: string, callback: (callType: FullCallType) => Promise<unknown>): CallProxyType;
    export {};

}

declare module "socket-function/src/profiling/getOwnTime" {
    export type OwnTimeObj = {
        name: string;
        time: number;
        ownTime: number;
    };
    export type OwnTimeObjInternal = OwnTimeObj & {
        lastStartTime: number;
        firstStartTime: number;
    };
    export declare function getOpenTimesBase(): OwnTimeObjInternal[];
    export declare const measureOverheadTime: number;
    export declare function getOwnTime<T>(name: string, code: () => T, onTime: (obj: OwnTimeObj) => void): T;

}

declare module "socket-function/src/profiling/measure" {
    import { StatsValue } from "socket-function/src/profiling/stats";
    /** NOTE: Must be called BEFORE anything else is imported!
     *      NOTE: Measurements on on by default now, so this doesn't really need to be called...
    */
    export declare function enableMeasurements(): void;
    /** NOTE: Must be called BEFORE anything else is imported! */
    export declare function disableMeasurements(): void;
    export declare function measureFnc(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
    export declare function nameFunction<T extends Function>(name: string, fnc: T): T;
    export declare function measureWrap<T extends (...args: any[]) => any>(fnc: T, name?: string): T;
    export declare function measureBlock<T extends (...args: any[]) => any>(fnc: T, name?: string): ReturnType<T>;
    /** NOTE: You should often call registerNodeMetadata for this as well. registerMeasureInfo
     *      is for logs, while registerNodeMetadata is for the overview page.
     */
    export declare function registerMeasureInfo(getInfo: () => string | undefined): void;
    /** IMPORTANT! Always finish the profile! If you don't, you will leak A LOT of memory
     *      (you leak all future measures, PER unfinished profile)!
     */
    export declare function startMeasure(): {
        finish: () => MeasureProfile;
    };
    export interface LogMeasureTableConfig {
        useTotalTime?: boolean;
        name?: string;
        setTitle?: boolean;
        thresholdInTable?: number;
        minTimeToLog?: number;
        mergeDepth?: number;
        maxTableEntries?: number;
        returnOnly?: boolean;
    }
    export interface FormattedMeasureTable {
        title: string;
        entries: {
            name: string;
            ownTime: number;
            fraction: number;
            equation: string;
        }[];
    }
    export declare function logMeasureTable(profile: MeasureProfile, config?: LogMeasureTableConfig): FormattedMeasureTable | undefined;
    export declare function measureCode<T>(code: () => Promise<T>, config?: LogMeasureTableConfig): Promise<T>;
    export declare function measureCodeSync<T>(code: () => T, config?: LogMeasureTableConfig): T;
    export interface MeasureProfile {
        startTime: number;
        endTime: number;
        entries: {
            [name: string]: ProfileEntry;
        };
        creator: string;
    }
    export declare function createMeasureProfile(): MeasureProfile;
    export declare function addToMeasureProfile(base: MeasureProfile, other: MeasureProfile): void;
    interface ProfileEntry {
        name: string;
        ownTime: StatsValue;
        totalTime: StatsValue;
        stillOpenCount: number;
    }
    export {};

}

declare module "socket-function/src/profiling/stats" {
    export interface StatsValue {
        count: number;
        sum: number;
        sumSquares: number;
        logn7Value: number;
        logn7Count: number;
        logn6Value: number;
        logn6Count: number;
        logn5Value: number;
        logn5Count: number;
        logn4Value: number;
        logn4Count: number;
        logn3Value: number;
        logn3Count: number;
        logn2Value: number;
        logn2Count: number;
        logn1Value: number;
        logn1Count: number;
        log0Value: number;
        log0VCount: number;
        log1Value: number;
        log1VCount: number;
        log2Value: number;
        log2VCount: number;
        log3Value: number;
        log3VCount: number;
        log4Value: number;
        log4VCount: number;
        log5Value: number;
        log5VCount: number;
        log6Value: number;
        log6VCount: number;
        log7Value: number;
        log7VCount: number;
        log8Value: number;
        log8VCount: number;
        log9Value: number;
        log9VCount: number;
    }
    export declare function createStatsValue(): StatsValue;
    export declare function addToStatsValue(stats: StatsValue, value: number): void;
    export declare function addToStats(stats: StatsValue, other: StatsValue): void;
    export interface StatsTop {
        countFraction: number;
        valueFraction: number;
        count: number;
        value: number;
        topHeavy: boolean;
    }
    /** Identifies cases where the value is concentrated in few instances. This indicates most of the value (time)
     *      is not spent on the common case, but on an outlier. Which isn't a problem, it just means that the measurements
     *      should be more precise, to pull that heavy case out.
     */
    export declare function getStatsTop(stats: StatsValue): StatsTop;

}

declare module "socket-function/src/profiling/statsFormat" {
    import { StatsValue } from "socket-function/src/profiling/stats";
    export declare function percent(value: number): string;
    export declare function formatStats(stats: StatsValue, config?: {
        noColor?: boolean;
        noSum?: boolean;
        noSpaces?: boolean;
    }): string;

}

declare module "socket-function/src/profiling/tcpLagProxy" {
    export declare function tcpLagProxy(config: {
        localPort: number;
        remoteHost: string;
        remotePort: number;
        lag: number;
        networkWriteSize?: {
            value: number;
        };
        networkReadSize?: {
            value: number;
        };
        networkWritePackets?: {
            value: number;
        };
        networkReadPackets?: {
            value: number;
        };
    }): Promise<void>;

}

declare module "socket-function/src/promiseRace" {
    export declare class PromiseLessLeaky<T> extends Promise<T> {
        constructor(executor: ((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) | undefined);
    }
    /** A promise race function which doesn't leak, unlike Promise.race

        See https://github.com/nodejs/node/issues/17469
        See https://bugs.chromium.org/p/v8/issues/detail?id=9858#c9

     */
    export declare function promiseRace<T extends readonly unknown[] | []>(promises: T): Promise<Awaited<T[number]>>;

}

declare module "socket-function/src/runPromise" {
    export declare const runAsync: typeof runPromise;
    export declare function runPromise(command: string, config?: {
        cwd?: string;
        quiet?: boolean;
        nothrow?: boolean;
        detach?: boolean;
    }): Promise<string>;

}

declare module "socket-function/src/sniTest" {
    export {};

}

declare module "socket-function/src/src" {
    /// <reference path="./node_modules/typenode/index.d.ts" />

    export { };

    declare global {
        namespace NodeJS {
            interface Module {
                original?: SerializedModule;
            }
        }
        interface SerializedModule {
            originalId: string;
            filename: string;
            // If a module is not allowed clientside it is likely requests will be empty,
            //  to save effort parsing requests for modules that only exist to give better
            //  error messages.
            requests: {
                // request => resolvedPath
                [request: string]: string;
            };
            asyncRequests: { [request: string]: true };
            // NOTE: IF !allowclient && !serveronly, it might just mean we didn't add allowclient
            //  to the module yet. BUT, if serveronly, then we know for sure we don't want it client.
            //  So the messages and behavior will be different.
            allowclient?: boolean;
            serveronly?: boolean;
            // Just for errors mostly
            alwayssend?: boolean;

            /** Only set if allowclient. */
            source?: string;

            seqNum: number;

            size?: number;
            version?: number;

            flags?: {
                [flag: string]: true;
            };
        }

    }
}

declare module "socket-function/src/storagePath" {
    export declare const getAppFolder: {
        (): string;
        reset(): void;
        set(newValue: string): void;
    };

}

declare module "socket-function/src/tlsParsing" {
    /// <reference types="node" />
    /// <reference types="node" />
    export declare function parseTLSHello(buffer: Buffer): {
        extensions: {
            type: number;
            data: Buffer;
        }[];
        missingBytes: number;
    };
    export declare const SNIType = 0;
    export declare function parseSNIExtension(data: Buffer): string[];

}

declare module "socket-function/src/types" {
    export type MaybePromise<T> = T | Promise<T>;
    export type Args<T> = T extends (...args: infer V) => any ? V : never;
    export type AnyFunction = (...args: any) => any;
    export declare function canHaveChildren(value: unknown): value is {
        [key in PropertyKey]: unknown;
    };

}

declare module "socket-function/src/webSocketServer" {
    /// <reference types="node" />
    /// <reference types="node" />
    /// <reference types="node" />
    import https from "https";
    import { Watchable } from "socket-function/src/misc";
    export type SocketServerConfig = (https.ServerOptions & {
        key: string | Buffer;
        cert: string | Buffer;
        port: number;
        /** You can also set `port: 0` if you don't care what port you want at all.  */
        useAvailablePortIfPortInUse?: boolean;
        public?: boolean;
        /** Tries forwarding ports (using UPnP), if we detect they aren't externally reachable.
         *      - This causes an extra request and delay during startup, so should only be used
         *          during development.
         *      - Ignored if public is false (in which case we mount on 127.0.0.1, so port forwarding
         *          wouldn't matter anyways).
        */
        autoForwardPort?: boolean;
        ip?: string;
        allowHostnames?: string[];
        allowHostnameFnc?: (hostname: string) => boolean;
        /** If the SNI matches this domain, we use a different key/cert.
         *      We remove subdomains until we find a match
         */
        SNICerts?: {
            [domain: string]: Watchable<https.ServerOptions>;
        };
    });
    export declare function startSocketServer(config: SocketServerConfig): Promise<string>;

}

declare module "socket-function/src/websocketFactory" {
    /// <reference types="node" />
    import tls from "tls";
    import { SenderInterface } from "socket-function/src/CallFactory";
    import type * as ws from "ws";
    export declare function getTLSSocket(webSocket: ws.WebSocket): tls.TLSSocket;
    /** NOTE: We create a factory, which embeds the key/cert information. Otherwise retries might use
     *      a different key/cert context.
     */
    export declare function createWebsocketFactory(): (nodeId: string) => SenderInterface;

}

declare module "socket-function/test" {
    export {};

}

declare module "socket-function/time/trueTimeShim" {
    export declare function getTrueTime(): number;
    export declare function getTrueTimeOffset(): number;
    export declare function waitForFirstTimeSync(): Promise<void> | undefined;
    export declare function shimDateNow(): void;
    export declare function getBrowserTime(): number;
    export declare function setGetTimeOffsetBase(base: () => Promise<number>): void;

}
